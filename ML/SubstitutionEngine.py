#
# Recipe substitution
#

import sys
import logging
import numpy as np
import re
import random
import IOTools
from sets import Set
import json
from Word2VecDistance import *
import pprint
import json
import getopt
from SupervisedML import *
from optparse import OptionParser
import Recipe
import os
from sklearn import svm
import hashlib
from CollectBasicStats import INGREDIENT_BIGRAM_FREQUENCY
import RDF
from bson.objectid import ObjectId

BULK_BUFFER_SIZE = 100 # size of batches for substitution writing

def dict_increment(d,x):
  if not x in d: 
    d[x] = 1
  else:
    d[x] = d[x] + 1

def approxFloat(x):
  return int(x*100)/100.0

def resolveEntity(e, rdb):
  e = rdb.cannonicalize_entity(e.lower())
  if not e in rdb.get_entitymap_dic(): return None, None
  return e, rdb.get_entitymap_dic()[e]['_id'].__str__()

#
# Find the id of an entity in the entitymap db, and ad the id to dictionary keyed by entity cannonical name
#
def resolveEntities(d, rdb):
  res = {}
  for key in d:
    key_ = rdb.cannonicalize_entity(key)
    res[key_] = d[key]
    res[key_]['id'] = rdb.get_entitymap_dic()[key_]['_id'].__str__()
  return res

class Substitution:
  def __init__(self):
    pass

#
# This class is used to encode a simple source->target substitution and some meta information
#
class SimpleSubstitution:

  #
  # source:     source ingredient (cannonical) name
  # sourceId:   entityMapping Id of the source entity
  # instanceId: Id of source instance inside the recipe.
  # target:     target ingredient
  # targetId:   eneityMapping Id of target ingredient
  # quantityRatio: ration between the quantity of the target and the quantity of the source, when substituting
  # origin:     name of algorithm or book or website from which the rule was derived
  # version:    version of algorithm or book 
  # inforlink:  In case the substitution comes from some website, or from some sample recipe, can include its url here
  # moreinfo:   Any additional information that could be useful for the substitution (e.g. "cook longer")
  # timestamp:  In case this was generated by a human, what is the timestamp of the sub recommendation
  # workeriId:  In case this was generated by a human, what is the id of this human?
  #
  def __init__(self, source='', sourceId = None, instanceId = '', target='', targetId = None, quantityRatio=1.0, probability=1.0, origin='', version='', infolink='', moreinfo = '', timestamp = '', workerId = ''):
    self.struct = {}
    self.source = source
    self.sourceId = sourceId
    self.instanceId = instanceId
    self.target = target
    self.targetId = targetId
    self.quantityRatio = quantityRatio
    self.probability = probability
    self.origin = origin
    self.version = version
    self.infolink = infolink
    self.moreinfo = moreinfo
    self.timestamp = timestamp
    self.workerId = workerId

  # for serialization, some default values are omitted
  def getDict(self):
    ret = {}
    if len(self.source): ret['source'] = self.source
    if not self.sourceId is None: ret['sourceId'] = self.sourceId.__str__()	
    if len(self.instanceId): ret['instanceId'] = self.instanceId
    if len(self.target): ret['target'] = self.target
    if not self.targetId is None: ret['targetId'] = self.targetId.__str__()
    if self.quantityRatio != 1.0: ret['quantityRatio'] = self.quantityRatio
    if self.probability != 1.0: ret['probability'] = self.probability
    if len(self.origin): ret['origin'] = self.origin
    if len(self.version): ret['version'] = self.version
    if len(self.infolink): ret['infolink'] = self.infolink
    if len(self.moreinfo): ret['moreinfo'] = self.moreinfo
    if len(self.timestamp): ret['timestamp'] = self.timestamp
    if len(self.workerId): ret['workerId'] = self.workerId
    ret['uid'] = hashlib.sha1(ret.__str__()).hexdigest()
    return ret


#
# This class is used for encoding a single ingredient source sub, that can be replaced with a list of options, each
# option a SimpleSubstitution object.
#
class ListSinglePick(Substitution):
  def __init__(self, source='', sourceId = '', instanceId = '', origin='',version='',infolink='',moreinfo='', probability = 1.0, workerid='', timestamp='', name=''):
    self.source = source
    self.sourceId = sourceId
    self.instanceId = instanceId
    self.origin = origin
    self.version = version
    self.infolink = infolink
    self.moreinfo = moreinfo
    self.workerid = workerid
    self.timestamp = timestamp
    self.name = name
    self.options = []

  def addOption(self, option):
    self.options.append(option)

  def len(self):
    return len(self.options)

  def getDict(self):
    ret = {'type' : 'list-single-pick'}
    if len(self.source): 
      ret['source'] = self.source
      ret['sourceId'] = self.sourceId.__str__()
    if len(self.instanceId):
      ret['instanceId'] = self.instanceId
    if len(self.origin): ret['origin'] = self.origin
    if len(self.version): ret['version'] = self.version
    if len(self.infolink): ret['infolink'] = self.infolink
    if len(self.moreinfo): ret['moreinfo'] = self.moreinfo
    if len(self.workerid): ret['workerid'] = self.workerid
    if len(self.timestamp): ret['timestamp'] = self.timestamp
    if len(self.name): ret['name'] = self.name

    ret['options'] = map(lambda x: x.getDict(), self.options)
    return ret

class MultiFoodSubstition(Substitution):
  def __init__(self):
    self.list = []
  
  def AddSub(self, sub):
    self.list.append(sub)
  
  def getDict(self):
    ret = {'type' : 'multi-food-change', 'and' : map(lambda x: x.getDict(), self.list)}
    return ret


############################################################################################
# A substitution rule is a class that logically describes a rule
# It has a method that takes a recipe and returns an application of the rule on that
# recipe.  The output of the application is one or more substitutions.
###########################################################################################
class SubstitutionRule:
  def __init__(self):
    pass

  # For optimizing computation, each rule can provide a set of ingredients that trigger
  # that rule.  Then, whenever a recipe comes along, the rules that are checked against
  # it are only those that are trigerred by the recipe's set of ingredients.
  # By default, all ingredients can trigger the rule.  This is marked by '*'.
  def getRelevantSourceIngredients(self):
    return '*'

  # For reporting the summary of the rule 58b2e3baece749126c223778applied in batch to all recipes
  def debugWorkSummary(self):
    pass

class ManualRule(SubstitutionRule):
  def __init__(self):
    pass

class ManualRule_for_ListSinglePick(ManualRule):
  # given an ingredient in the "sources" dictionary, it is substituted by a ListSinglePick substitution from the "targets".  
  # Both the "sources" and the "targets" are dictionaries keyed by a cannonical name, valued with {'qty':..., 'id':...} where
  # the 'qty' is used for computing the quantity ratio and the 'id' is the _id of the entity in the entitymap collection.
  #
  # source is removed from the target list (if it is there).
  # the sources and targets parameters a dictionaries, with values equalling the quantity ratio.
  # so for example if
  # sources = {'X':1.0, 'Y' : 2.0},  targets = {'A':1.3, 'B':1.4}
  # whenever 'X' is in the recipe, it will create a sub with options 'A' (with quantity ratio 1.3) and 'B' (with quantity ratio 1.4)
  # whenever 'Y' is in the recipe, it will create a sub with options 'A' (quantity ratio 1.3/2=0.65) and 'B' (with quantity ratio 1.4/2=0.7)
  # the "filter", which is a lambda predicate is used in order to apply the rule only to a subset.
  # This class assumes the probability, the infolink and the moreinfo are the same for all options.
  #
  # Construction can be done either using a document from the database (db_document) or by indiviually setting fields
  #
  def __init__(self, rdb, db_document = None, origin="", version="", probability=1.0, name="", infolink="", moreinfo="", cond=None, sources=[], targets=[], debug_file=None, debug=False):
    self.debug_count = 0
    self.debug_file = debug_file
    self.rdb = rdb
    self.debug = debug
    self.db_document = db_document
    if db_document is None:
      self.sources = sources
      self.targets = targets
      self.cond = cond
      self.origin = origin
      self.version = version
      self.probability = probability
      self.name = name  # in order to indentify the sub rule inside the recipe later
      self.infolink = infolink
      self.moreinfo = moreinfo
    else:
      self.sources = db_document["sources"]
      self.targets = db_document["targets"]
      self.cond = db_document["cond"]
      self.origin = db_document["origin"]
      self.version = db_document["version"]
      self.probability = db_document["probability"]
      self.name = db_document["name"]
      self.infolink = db_document["infolink"]
      self.moreinfo = db_document["moreinfo"]
      self.sources_dic = {}
    for source in self.sources:
      self.sources_dic[source["name"]] = source
    self.targets_dic = {}
    for target in self.targets:
      self.targets_dic[target["name"]] = target

  # For indexing, use only the source ingredients in the rule
  def getRelevantSourceIngredients(self):
    return self.sources_dic.keys()
  
  # Checks if the condition in the rule applies to the given recipe r, with respect
  # to the matching ingredient
  def check_cond(self, cond, r, ing_name):
    ings = r.getIngs() 
    ing_names = map(lambda x: x['cannonical'], ings)

    
    def recipe_has_ingredient(ing_):
      return (self.rdb.cannonicalize_entity(ing_) in ing_names)
      
    ingredient_absolute_quantity_grams = 0.0
    prob_served_raw = r.getTagProb('is_salad') # a patch for now feb 28 2017
    prob_served_cooked = 1 - prob_served_raw
    prob_part_of_sauce = 0.8 if rdb.cannonicalize_entity(ing_name) == rdb.cannonicalize_entity('tahini') else 0.0 # a patch for now feb 28 2017
    prob_for_greasing_pans = 0.0 # a patch for now feb 28 2017

    recipe_has_vegetable = False
    for ing_name in ing_names:
      if self.rdb.getEntityUSDAFamily(ing_name) == 'Vegetables and Vegetable Products':
        recipe_has_vegetable = True
        break


    for i in range(len(ing_names)):
      if ing_names[i] == ing_name and ings[i]['gram'] is not None:
        ingredient_absolute_quantity_grams = ings[i]['gram']    
 
    env = {
      'recipe_tag_prob' : r.getTagProb,
      'ingredient_absolute_quantity_grams' : ingredient_absolute_quantity_grams,
      'prob_served_raw' : prob_served_raw,
      'prob_served_cooked' : prob_served_cooked,
      'prob_part_of_sauce': prob_part_of_sauce,
      'prob_for_greasing_pans' : prob_for_greasing_pans,
      'recipe_has_ingredient' : recipe_has_ingredient,
      'recipe_has_vegetable' : recipe_has_vegetable,
      '__builtin__' : {}}

    e = eval(cond, env)
    if self.debug: print '  Evaluating condition %s result = %d' % (self.cond, e)
    return e

  # apply the rule
  def apply(self, r):
    res = []
    #ingredient_list, original_ings, uids = self.rdb.getCannonicalIngredientList(r, with_uid=True)
    ings = r.getIngs()
    if debug: print 'ingredient_list len = %d' % len(ings)
    if debug: print 'Trying to apply %s to %s' % (self.db_document.__str__(), ings.__str__())
    if debug: print 'title = %s' % (r.getTitle())
    if debug: print 'tags = %s' % (r.getTags().__str__())

    for i in range(len(ings)):
      ing = ings[i]["cannonical"]
      uid = ings[i]["uid"]
      if ing in self.sources_dic:
        if debug: print '  ingredient: %s, trying to evaluate %s ' % (ing, self.cond)
        if not self.check_cond(self.cond, r, ing): continue # check the condition w.r.t. recipe and ingredient
        if debug: print '    included in rule'
        lsp = ListSinglePick(
          source=ings[i]["food"],  # the original (un-cannonicalized) ingredient 
          sourceId=self.sources_dic[ing]['id'], 
          instanceId = uid, 
          origin=self.origin, 
          version=self.version,  
          infolink=self.infolink,
          moreinfo=self.moreinfo,
          name=self.name)
        for t in self.targets_dic:
          if t is None: continue
          if t == ing: continue
          # A particular target ingredient might have its own condition.
          if 'cond' in self.targets_dic[t]:
            if not self.check_cond(self.targets_dic[t]['cond'], r, ing): continue
          if debug: print '  Substituting %s=%s ---> %s' % (ings[i]["food"], ing, t)
          lsp.addOption(SimpleSubstitution(
            target = t,
            targetId = self.targets_dic[t]['id'],
            quantityRatio = self.targets_dic[t]['qty']/self.sources_dic[ing]['qty'],
            probability = self.probability,
            moreinfo = self.targets_dic[t]['moreinfo'] if 'moreinfo' in self.targets_dic[t] else ''))
        res.append(lsp)
        self.debug_count = self.debug_count + 1
    return map(lambda x: x.getDict(), res)
            
  def debugWorkSummary(self):
    if self.debug_file is not None:
      self.debug_file.write('%4d Manual(%s) %s->%s\n' % (self.debug_count, self.origin, self.sources.__str__(), self.targets.__str__()))

class AutomaticRule(SubstitutionRule):
  def __init__(self):
    pass

class Word2VecRule(AutomaticRule):
  # p is similarity cuttof
  # pcv is context similarity cutoff
  # cvecname: context vecname (optional)
  def __init__(self, rdb, p=0.5, pcv=0.1, debug=True, vecname="word2vec", cvecname=None):
    self.rdb = rdb	
    self.w2vd = Word2VecDistance(rdb=rdb, vecname=vecname, cvecname=cvecname)
    self.precompute_nn = self.w2vd.SortCosineAll(p)  # compute all nearest neighbors
    self.entitymap_dic = rdb.get_entitymap_dic()
    self.debug = debug
    # For debugging
    self.suspicious_entity_mappings = {}
    self.applied_subs = {}
    self.vecname = vecname
    self.cvecname = cvecname

  def apply(self, r):
  
    #ings, original_ings, uids = self.rdb.getCannonicalIngredientList(r, with_uid=True)
    ings = r.getIngs()
    ing_names = map(lambda x: x['cannonical'], ings)
    ing_uids = map(lambda x: x['uid'], ings)
    res = []
    # compute sum of ingredient vectors (for context checking)
    for ii in range(len(ings)):
      ing = ing_names[ii]
      uid = ing_uids[ii]
      if ing is None: continue
      if not ing in self.precompute_nn: continue
      if not 'ndb_no' in self.entitymap_dic[ing]: continue  
      ndb_no = self.entitymap_dic[ing]['ndb_no']    
      is_manual = self.entitymap_dic[ing]['origin'] == 'MANUAL'  if 'origin' in self.entitymap_dic[ing] else True # hack for feb 7 2017...ugly as all hell

      usda_item = self.rdb.getUSDAIngredientByNDB(ndb_no)
      if usda_item is None: 
        print '!!!', ing
        dict_increment(self.suspicious_entity_mappings, ing)
        continue
      if not 'foodGroup' in usda_item: continue # I've seen this with respect to ndb_no=0000
      group = usda_item['foodGroup']
      lsp = ListSinglePick(source=ing, sourceId=self.rdb.get_entitymap_dic()[ing]['_id'], instanceId = uid, version='v1', origin='Word2VecCosineSim', moreinfo = 'M' if is_manual else 'A')
      for prob, ing2 in self.precompute_nn[ing]:
        if not 'ndb_no' in self.entitymap_dic[ing2]: continue
        if not 'origin' in self.entitymap_dic[ing2]: 
          pass
          #continue
        ndb_no2 = self.entitymap_dic[ing2]['ndb_no']  
        prob = -prob
        is_manual2 = self.entitymap_dic[ing2]['origin'] == 'MANUAL'  if 'origin' in self.entitymap_dic[ing2] else True # hack for feb 7 2017...ugly as all hell
        if not is_manual2 and self.debug: dict_increment(self.suspicious_entity_mappings, ing2)
        usda_item2 = self.rdb.getUSDAIngredientByNDB(ndb_no2)
        if usda_item2 is None:
          dict_increment(self.suspicious_entity_mappings, ing2)
          continue
        if not 'foodGroup' in usda_item2: continue  # I've seen this with respect to ndb_no=0000
        group2 = usda_item2['foodGroup']
        if group != group2: continue 
        moreinfo = 'M' if is_manual2 else 'A'
        if self.cvecname is not None and self.cvecname != '' and self.cvecname != self.vecname:
          cvsim = self.w2vd.ContextSimilarity(context=ings, target=ing, sub=ing2, normalized = False)
          cvsim_control = self.w2vd.ContextSimilarity(context=ings, target=ing, sub=ing, normalized = False)
          csa = self.w2vd.SimilarityAsymmetric(ing, ing2, normalized = False)
          csa_control = self.w2vd.SimilarityAsymmetric(ing, ing, normalized = False)
          moreinfo = moreinfo + ' cvsim=%.02f/%.02f asym=%.02f/%0.02f' % (cvsim, cvsim_control, csa, csa_control)
        ss = SimpleSubstitution(target=ing2, targetId=self.rdb.get_entitymap_dic()[ing2]['_id'].__str__(), probability=prob, moreinfo = moreinfo)
        lsp.addOption(ss)
      if not lsp.len(): continue
      if not is_manual and self.debug: dict_increment(self.suspicious_entity_mappings, ing)
      if self.debug: dict_increment(self.applied_subs, self.debugStr(lsp))
      res.append(lsp.getDict())            
    return res
 

  # These are some debug utility functions, computing and printing summaries at the end of the work.

  # convert a list-single-pick to a debug string, for the purpose of counting all the substitutions that were done.
  def debugStr(self, lsp):
    
    # remove recipe id's, so we can uniquely count substitution applications
    js = lsp.getDict()
    js['sourceId'] = '#'
    js['instanceId'] = '#'
    for o in js['options']: o['targetId']='#'

    ret = json.dumps(js)
    return ret

  def getEntityMapSummary(self,ing):
    ndb = self.entitymap_dic[ing]['ndb_no']
    automan = self.entitymap_dic[ing]['origin']
    res = ing + ":" +automan[0]+":"
    if self.usda.getByNDB(ndb) is None: return res +'[None]'
    return res+'"'+self.usda.getByNDB(ndb).attrib['desc']+'"'

  def debugWorkSummary(self):
    suspicious_list = map(lambda k: (-self.suspicious_entity_mappings[k],k), self.suspicious_entity_mappings.keys())
    suspicious_list.sort()
    f = open('data/suspicious_entity_list.txt', 'w')
    for n,ing in suspicious_list:
      ndb = self.entitymap_dic[ing]['ndb_no']
      usda_obj = self.rdb.getUSDAIngredientByNDB(ndb)
      if usda_obj is None: #self.usda.getByNDB(ndb) is None:
        print '!!!', ing
        f.write(ing+', ' + ('n=%d'%self.suspicious_entity_mappings[ing]) + ', '+ndb+', '+' "Error: number doesnt exist in usda"\n')
      else:
        f.write(ing+', '+('n=%d'%self.suspicious_entity_mappings[ing])+', '+ndb+', '+usda_obj['desc']+', ' + usda_obj['foodGroup']+'\n')
    f.close()

    f = open('data/word2vec_sub_frequency.txt', 'w')
    f.write('Number of substitutions used: %d\n' % len(self.applied_subs))
    applied_subs_list = map(lambda k: (-self.applied_subs[k],k), self.applied_subs.keys())
    applied_subs_list.sort()
    for n,sub in applied_subs_list:
      sub = json.loads(sub)
      for o in sub['options']:
        f.write('%d,%s,%s,%.02f\n' % (-n, sub['source'], o['target'], o['probability'])) # sub=%s\n' % (n, sub))
    f.close()

############################################################################################
# This is a legacy rule, calculated from an old demo.
###########################################################################################
class LegacyRule(AutomaticRule):
  def __init__(self, rdb):
    print 'Initializing legacy recipe rule...'
    self.urn2recipe = {}
    for lr in LegacyRecipes().getAll():
      if 'substitutionRule' in lr: continue # This means it's a child recipe, not interested in that here
      if 'urn' in lr:
        self.urn2recipe[lr['urn']] = lr
    print 'Done.'
    self.rdb = rdb
    self.bad_entities = {} # keep track of entities in legacy recipes that were not found in new
    self.counts = {}
    self.general_debug = ''

  def apply(self, r):
    if not 'urn' in r: return []
    res = []
    if r['urn'] in self.urn2recipe:
      legacy = self.urn2recipe[r['urn']]
      for step in legacy['steps']:
       for line in step['lines']:
        if len(line["subs"] ) > 0:
          source_cann, source_cann_id = resolveEntity(line["food"], self.rdb)
          if source_cann is None:
            dict_increment(self.bad_entities, line["food"])
            continue

          # Try to fit the instanceId (uid) of the source ingredient in the recipe
          ings, original_ings, uids = self.rdb.getCannonicalIngredientList(r, with_uid = True)
          instanceId = ''
          for ii in range(len(ings)):
            if ings[ii] == source_cann: instanceId = uids[ii]

          subname = "LegacyRecipeId:" + legacy["_id"].__str__()
          lsp = ListSinglePick(
            source = source_cann,
            sourceId = source_cann_id,
            instanceId = instanceId, 
            origin = 'Legacy Supervised ML Output',
            version = "1",
            name = subname)
          for sub in line["subs"]:
            target_cann, target_cann_id = resolveEntity(sub["substituteFor"], self.rdb)
            if target_cann is None:
              dict_increment(self.bad_entities, sub["substituteFor"])  # logging the bad event
              continue
            lsp.addOption(SimpleSubstitution(
              target = target_cann, targetId = target_cann_id, 
              probability = float(sub["probability"]) if len(sub["probability"]) else 1.0))
          substitute_text = '%s=>%s' % (source_cann, target_cann)
          dict_increment(self.counts, substitute_text)
          if substitute_text == 'rice vinegar=>brown rice' or substitute_text == 'grated cauliflower=>brown rice': # a weird substitute
            self.general_debug = self.general_debug + 'Suspicious sub: ' + substitute_text + ' ' + legacy['_id'].__str__() + '\n'                   
          res.append(lsp.getDict())
    return res

  def debugWorkSummary(self):
    f = open('data/legacy_rule_summary.txt', 'w')
    f.write('Bad entities in legacy data:\n')
    for be in self.bad_entities:
      f.write('%5d  %s\n' % (self.bad_entities[be], be))
    f.write('\n\nSubstitute counts:\n')
    for c in self.counts:
      f.write('%5d %s\n' % (self.counts[c], c))
    f.write(self.general_debug)
    f.close()


############################################################################################
# Predict substitutions using supervised ML from feedback
# This class uses legacy feedback (from a file created by Orly) to derive predictions
# The feedbackQuery is a mongo query that selects the feedback entries relevant to this
# rule. 
# The sources is a set or an array of all ingredient sources (e.g. 'rice', 'white rice', 
# 'brown rice'.  Target is the target ingredient.
# Vecname is the vector name from recipeVecs to use
###########################################################################################
class SupervisedMLRule(AutomaticRule):
  def __init__(self, rdb, feedbackQuery, sources, target, vecname):

    self.rdb = rdb
    self.target = target
    self.sources = sources
    self.recipevecs = rdb.getRecipeVecs(vecname)

    if target in rdb.get_entitymap_dic():
      self.targetId = rdb.get_entitymap_dic()[target]['_id']
    else:
      self.targetId = ''
    print 'Learning %s / %s' % (feedbackQuery.__str__(), target)

    feedbacks = rdb.findFeedback(query=feedbackQuery)
    ids = []
    labels = []
    self.query = feedbackQuery
    for feedback in feedbacks:
      recipeId = feedback['recipeId']
      for f in feedback['feedback']:
        if rdb.cannonicalize_entity(f['info']['target']) == target: #  e.g. 'grated cauliflower'
          labels.append((f['info']['polarity']+1)/2)
          ids.append(recipeId)

    for _id in ids:
      if not _id in self.recipevecs:
        print 'Warning ', _id
    examples = map(lambda x: self.recipevecs[x] if x in self.recipevecs else None, ids)

    zipped = zip(examples, labels)
    zipped = filter(lambda x: x[0] is not None, zipped)
    unzipped = zip(*zipped)

    examples = unzipped[0]
    labels = unzipped[1]

    # Try a bunch of SVM classifiers, with different regularization parameters C
    # 5-flod cross validations will be done in the supervisedML class to choose the best.
    classifiers = [
      svm.SVC(C=0.001, probability = True),svm.SVC(C=0.005, probability = True),
      svm.SVC(C=0.01, probability = True), svm.SVC(C=0.05, probability = True),
      svm.SVC(C=0.1, probability = True), svm.SVC(C=1, probability = True), 
      svm.SVC(C=5, probability = True), svm.SVC(C=10, probability = True), 
      svm.SVC(C=20, probability = True), svm.SVC(C=50, probability = True)]

    self.sml = SupervisedML(examples, labels, classifiers)
    self.debug_counter = 0
    self.debug_total_prob = 0.0
    print 'Done.'

  def isSourceAdmissible(self, ing):
    return ing is not None and ing.lower() in self.sources

  def apply(self, recipe):
    res = []
    ings = recipe.getIngs()
    canns = map(lambda x: x["cannonical"], ings)
    uids = map(lambda x: x["uid"], ings)
    found = False
    for ii in range(len(ings)):
      cann = canns[ii]
      if self.isSourceAdmissible(cann):
        instanceId = uids[ii] 
        found = True
        break
    if not found: return res
    
    if not (recipe.getId() in self.recipevecs): return res

    vec = self.recipevecs[recipe.getId()]
    prob = self.sml.predict(vec)

    self.debug_counter = self.debug_counter + 1
    self.debug_total_prob = self.debug_total_prob + prob
    #if not ing in self.rdb.get_entitymap_dic()
#    cann_ing = self.rdb.cannonicalize_entity(ing)
    if cann is None: return res
    lsp = ListSinglePick(
      source = cann,
      sourceId = self.rdb.get_entitymap_dic()[cann]['_id'],
      instanceId = instanceId, 
      version = "1",
      origin = 'SupervisedML:FromLegacyLabels',
      name = 'sources:%s:target=%s' % (self.sources.__str__(), self.target))  
    lsp.addOption(SimpleSubstitution(
      target = self.target, targetId = self.targetId, probability = prob))
    res.append(lsp.getDict())
    return res
    

  def debugWorkSummary(self):
    f = open('data/supervisedML:%s:%s.txt' % (self.sources.__str__(), self.target), 'w')
    f.write('Number of predictions: %d\n'% self.debug_counter)
    f.write('Average predicted probability: %f\n' % ((self.debug_total_prob / self.debug_counter) if self.debug_counter else 0))
    f.close()

############################################################################################
# This is basically a container of substitution rules.  The run method applies the rules
# and writes the output to the db.
###########################################################################################
    

class SubstitutionEngine():

  # use an index from (source) ingredients to run faster
  class Turbo():
    def __init__(self, rdb):
      # mapping from ingredients to tules.  The ingredient '*' matches everything
      self.ing_to_rules = {'*' : Set([])}
      self.rdb = rdb

    # Store information about the rule that can be used to quickly check, given a recipe, whether
    # there is a point in applying the rule.
    #
    def indexRule(self, rule):
      relevant_source_ingredients = rule.getRelevantSourceIngredients()
      if relevant_source_ingredients == '*':
        self.ing_to_rules['*'].add(rule)
      else: # It's an array of ingredients
        for ing in relevant_source_ingredients:
          if not ing in self.ing_to_rules:
            self.ing_to_rules[ing] = Set([rule])
          else:
            self.ing_to_rules[ing].add(rule)    
    #
    # Given a recipe, retrieve the set of applicable rules
    #
    def getRuleSet(self, recipe):
      ings = recipe.getIngs()
      ingredient_cann_names = map(lambda x: x["cannonical"], ings)
      ret = self.ing_to_rules['*'] # Everybody goes through the * rules
      for ing in ingredient_cann_names:
        if ing is not None and ing in self.ing_to_rules: ret = ret | self.ing_to_rules[ing]
      return ret

  # initialize with recipe db
  def __init__(self, rdb, debug=True):
    self.rdb = rdb
    self.rules = []
    self.debug = debug
    self.turbo = self.Turbo(rdb)

  def addRule(self, rule):
    self.rules.append(rule)
    self.turbo.indexRule(rule)

  def run(self,limit=0, recipe_ids = []):
    query = {}
    if len(recipe_ids):
      object_ids = map(lambda x: ObjectId(x), recipe_ids)
      query = {'_id' : {'$in' : object_ids}}
    recipes = self.rdb.findRecipes(query = query, limit=limit)
    c = 0
    substitutionBuffer = []
    for recipe in recipes:
      if not recipe.isValid(): continue
      c = c + 1
      print '%d:%s' % (c, recipe.getId())
      subs = []
      rule_set = self.turbo.getRuleSet(recipe)
      for rule in rule_set:
        subs = subs + rule.apply(recipe)
      if not self.debug and len(subs)>0:
        substitutionBuffer.append({
          'recipeId':recipe.getId() , 
          '_class' : 'com.mfe.model.recipe.Substitutions', 
          'subs':subs})
        if len(substitutionBuffer) == BULK_BUFFER_SIZE:
          rdb.bulkInsertSubstitutions(substitutionBuffer)
          substitutionBuffer = []
      if limit and c == limit: break
    if len(substitutionBuffer):
      rdb.bulkInsertSubstitutions(substitutionBuffer)

    for rule in self.rules:
     rule.debugWorkSummary()

        

if __name__ == "__main__":

  from RecipeNearestNeighbor import NearNeighborSubstitutionRule
  parser = OptionParser()
  parser.add_option("-v", "--vecname", dest="vecname", help="Name of vector mapping (for word2vec alg)", default='word2vec', metavar="VECNAME")
  parser.add_option("-c", "--cvecname", dest="cvecname", help="Name of context vector mapping (for word2vec alg)", default=None, metavar="CVECNAME")
  parser.add_option("-s", "--min_sim", dest="min_sim", help="Min similarity for word2vec sub", default="0.4", metavar="MIN_SIM")
  parser.add_option("-l", "--limit", dest="limit", help="Limit number of recipes", default="0", metavar="LIMIT")
  parser.add_option("-x", "--delete_collection", dest="delete_collection", help="Delete substitutions collections before starting (default True)", default="True", metavar="DELETE_COLLECTION")
  parser.add_option("--mo", "--manual_origin", dest="manual_origin", help="Origins of manual rules to work with as comma-separated list.  Blank (default) for all ", default="", metavar="MANUAL_ORIGIN")
  parser.add_option("--ids", "--recipe_ids", dest="recipe_ids", help="Either name of json file with list of ids to run on, or comma-separated list of ids.  If left blank (default) will run on everything",
default="", metavar="RECIPE_IDS")
  parser.add_option("--nnbr", "--near_neighbors", dest="near_neighbors", help="Use near neighbors algorithm.  Default True", default="True", metavar = "NEAR_NEIGHBORS")
  parser.add_option("--sml", "--supervisedml", dest="supervisedml", help="Use supervised ML from feedback examples.  Default True", default="True", metavar="SUPERVISEDML")
  parser.add_option("--svn", "--sim_vecname", dest="sim_vecname", help="Name of vector for recipe similarity in near-neighbor rule", default="word2vec", metavar="SIM_VEC_NAME")
  parser.add_option("--st", "--sim_threshold", dest="sim_threshold", help="Threshold for similarity in near-neighbor rule, default=0.6", default="0.6", metavar="SIM_THRESHOLD")
  parser.add_option("--mt", "--match_threshold", dest="match_threshold", help="Threshold for match in near-neighbor rule, default=0.6", default="0.6", metavar="MATCH_THRESHOLD")
  parser.add_option("--d", "--debug", dest="debug", help="Debug mode (default False)", default="False", metavar="DEBUG")
  parser.add_option("--grt", "--gram_ratio_threshold", dest="gram_ratio_threshold", help="Maximal ratio between gram values of ingredients of two recipes that is allowed for match.  Default 10.", default="10", metavar="GRAM_RATIO_THRESHOLD")
  rdb = IOTools.RecipeDB(option_parser = parser)
  (options, args) = parser.parse_args()
  debugManualRulesFile = open('data/manual_rules_count.txt', 'wt')

  debug = eval(options.debug)

  se = SubstitutionEngine(rdb=rdb,debug=debug)

  # Get rules from the rules db
  manual_origin = [] if options.manual_origin=="" else options.manual_origin.split(",")
  manual_origin = map(lambda x: x.lower(), manual_origin)
  print 'Using only manual substitution rules of origin ', manual_origin.__str__()
  num_rules=0
  for rule in rdb.getManualSubRulesColl().find({}):
    if len(manual_origin) and rule["origin"].lower() not in manual_origin: continue
    num_rules = num_rules + 1
    se.addRule(ManualRule_for_ListSinglePick(
      rdb = rdb,
      db_document = rule, debug_file = debugManualRulesFile, debug=debug
    ))
  print 'Total number of manual rules = %d' % num_rules
  #se.addRule(Word2VecRule(rdb=rdb, vecname = options.vecname, cvecname = options.cvecname, p=eval(options.min_sim)))
  
  if eval(options.near_neighbors):
    se.addRule(
      NearNeighborSubstitutionRule(
        rdb=rdb, sim_vecname = options.sim_vecname, 
        sim_threshold=eval(options.sim_threshold), match_threshold=eval(options.match_threshold), 
        source_ing = '', debug=debug,
        bigram_table_name = INGREDIENT_BIGRAM_FREQUENCY,
        gram_ratio_threshold = eval(options.gram_ratio_threshold)))

  if eval(options.supervisedml):
    se.addRule(
      SupervisedMLRule(
        rdb, {'taskId' : 'legacy:rice substitutions'}, ['rice', 'white rice', 'brown rice'], target = rdb.cannonicalize_entity('cauliflower'), vecname='word2vec'))
    se.addRule(
      SupervisedMLRule(
        rdb, {'taskId' : 'legacy:rice substitutions'}, ['rice', 'white rice', 'brown rice'], target = rdb.cannonicalize_entity('bulgur'), vecname='word2vec'))
    se.addRule(
      SupervisedMLRule(
        rdb, {'taskId' : 'legacy:rice substitutions'}, ['rice', 'white rice', 'brown rice'], target = rdb.cannonicalize_entity('quinoa'), vecname='word2vec'))
  

  if eval(options.delete_collection): rdb.deleteSubstitutionsCollection()
  recipe_ids = []
  if len(options.recipe_ids):
    if options.recipe_ids.lower() == 'all':
      recipe_ids = []
    elif os.path.exists(options.recipe_ids):
      recipe_ids = json.loads(file(options.recipe_ids).read())["ids"]
    else:
      recipe_ids = options.recipe_ids.split(",")
  se.run(limit=eval(options.limit), recipe_ids = recipe_ids)

  debugManualRulesFile.close()



  






